[
  {
    "objectID": "Data-Processing.html",
    "href": "Data-Processing.html",
    "title": "PUMS Census Data Processing in R",
    "section": "",
    "text": "The following document explores the extraction of the Public Use Microdata Sample Census data using the API that gives person-level data between, and including, the years 2010 and 2022."
  },
  {
    "objectID": "Data-Processing.html#a-quick-intro",
    "href": "Data-Processing.html#a-quick-intro",
    "title": "PUMS Census Data Processing in R",
    "section": "",
    "text": "The following document explores the extraction of the Public Use Microdata Sample Census data using the API that gives person-level data between, and including, the years 2010 and 2022."
  },
  {
    "objectID": "Data-Processing.html#now-for-the-code-to-query-this-data.",
    "href": "Data-Processing.html#now-for-the-code-to-query-this-data.",
    "title": "PUMS Census Data Processing in R",
    "section": "Now for the code to query this data.",
    "text": "Now for the code to query this data.\nWe know we want to use the tidyverse package, as we’ve established in the ST 558 course that tibbles are easy to manipulate and format. Let’s also load in the tidycensus package, which works with this Census API. The jsonlite package helps to parse JSON data. The httr package is used to effectively deal with URLs.\n\nlibrary(tidyverse)\nlibrary(tidycensus)\nlibrary(jsonlite)\nlibrary(httr)\n\nNow that we have the libraries loaded, we can use the example function call and the httr package to ‘GET’ the structure of the example page.\n\nurl_census &lt;- 'https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'\ncensus_info &lt;- httr::GET(url_census)\nstr(census_info, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-10-01 01:57:15\"\n $ times      : Named num [1:6] 0 0.055 0.0749 0.1259 0.336 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nLet’s try creating a helper function, parsing_fun, that takes what we found from the GET() function and turn it into a nicely formatted tibble. We need to do some corrections with formatting, as the column names weren’t initially recognized. The data we are interested in is in the content portion of census_info. The str() function above gives a good visual for this.\n\nparsing_fun &lt;- function(response) {\n  parsed &lt;- fromJSON(rawToChar(response$content))\n  content_info &lt;- as_tibble(parsed)\n  colnames(content_info) &lt;- content_info[1,]\n  content_info &lt;- content_info[-1,]\n  content_info\n}\n\nNow, we can begin the actual creation of the function. First, let’s specify the options for a few of the function arguments we will use.\n\nnumeric_vars &lt;- c('AGEP','GASP','GRPIP','JWAP', 'JWDP','JWMNP')\ncategory_vars &lt;- c('FER','HHL','HISPEED', 'JWTRNS','SCH','SCHL','SEX')\ngeo_vars &lt;- c('All', 'Region', 'Division', 'State')\n\nSecond, we can create the single year function, user_input, which has default values for the first four arguments and the fifth argument is optional. We begin with the year input, where we need to ensure a valid year was entered, then the numeric, category, and geography levels are validated. The numeric variables are then converted to numeric or time values, depending on the attribute. The categorical variables are turns in to factors.\nUsers can specify specific Regions, Divisions, or States in the fifth (optional) argument.\nFinally, the variable ‘Year’ is added to the output_tibble to specify which year the observation data came from. This is important when querying multiple years in the next part.\n\nuser_input &lt;- function(x=c(2022),\n                       y=c(\"AGEP\"),\n                       z=c(\"SEX\"),\n                       geo_lvl=\"All\",\n                       specs=NULL) {\n  if (!all(x %in% c(2010:2022))) {\n    stop('expected a number')\n  }\n  \n  if (!all(y %in% numeric_vars)) {\n    stop('expected a numeric variable from the following list: AGEP, GASP, GRPIP, JWAP, JWDP, JWMNP')\n  }\n  number_vars_specified &lt;- unique(c(y, \"PWGTP\"))\n\n  if (!all(z %in% category_vars)) {\n    stop('expected a categorical variable from the following list: FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX')\n  }\n  category_vars_specified &lt;- z\n  variable_combo &lt;- paste(c(number_vars_specified, category_vars_specified), collapse = ',')\n  if (!geo_lvl %in% geo_vars){\n    stop('expected a geographical level from the following list: All, Region, Division, State')\n  }\n  \n  url_base &lt;- paste0('https://api.census.gov/data/', x, '/acs/acs1/pums?get=', variable_combo)\n  \n  if (!is.null(specs)) {\n    filter &lt;- paste0('&', names(specs), '=', specs)\n    url_base &lt;- paste0(url_base, paste(filter, collapse = ''))\n  }\n  response &lt;- GET(url_base)\n  \n  output_tibble &lt;- parsing_fun(response)\n  \n  output_tibble$PWGTP &lt;- as.numeric(output_tibble$PWGTP) # Make sure PWGTP is read as numeric.\n  \n  for (i in numeric_vars) {\n    if (i %in% names(output_tibble)) {\n      output_tibble[[i]] &lt;- as.numeric(output_tibble[[i]])\n    }\n  }\n  \n  time_vars &lt;- intersect(numeric_vars, c('JWAP','JWDP'))\n  \n  for (i in time_vars) {\n    if (i %in% names(output_tibble)) {\n      output_tibble[[i]] &lt;- as.numeric(output_tibble[[i]])+0.5 #halfway point\n    }\n  }\n  \n  for (i in category_vars) {\n    if (i %in% names(output_tibble)) {\n      output_tibble[[i]] &lt;- as.factor(output_tibble[[i]])\n    }\n  }\n  \n  output_tibble$Year &lt;- x\n  \n  class(output_tibble) &lt;- c(\"census\", class(output_tibble)) # Add a class for \"census\".\n  \n  return(output_tibble)  \n}\n\nLet’s test how this works using a ‘Default’ input, where no arguments have specific values changed from the default.\n\ndefault_tibble &lt;- user_input()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\ndefault_tibble\n\n# A tibble: 3,373,378 × 4\n    AGEP PWGTP SEX    Year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt;\n 1    17     3 2      2022\n 2    73    42 1      2022\n 3    22    11 1      2022\n 4    82    32 2      2022\n 5    19    31 2      2022\n 6    88    32 1      2022\n 7    80    45 1      2022\n 8    33    37 1      2022\n 9    44    29 1      2022\n10    36    55 1      2022\n# ℹ 3,373,368 more rows\n\n\nThe following is the testing of the single year function where the user specified 2021 as the year, AGEP and GRPIP as the numeric variables, and SEX and SCHL as the categorical variables. Here, the geography level is not specified, so it defaults to a value of ‘All.’\n\nuser_input(x = 2021,\n           y = c(\"AGEP\", \"GRPIP\"),\n           z = c(\"SEX\", \"SCHL\"))  \n\n# A tibble: 3,252,599 × 6\n    AGEP GRPIP PWGTP SEX   SCHL   Year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt;\n 1    36     0    35 1     11     2021\n 2    19     0    35 1     19     2021\n 3    57     0    70 1     22     2021\n 4    29     0   149 1     14     2021\n 5    26     0   177 1     1      2021\n 6    80     0    14 2     21     2021\n 7    47     0    14 1     16     2021\n 8    80     0    95 2     14     2021\n 9    21     0    31 1     19     2021\n10    19     0    27 2     19     2021\n# ℹ 3,252,589 more rows\n\n\nLooks good! Now, we can wrap this single year function into a multi_year_user_input function. The user can specify multiple years, instead of just one, and this data is combined into a tibble.\n\nmulti_year_user_input &lt;- function(x_multi = 2022,\n                                  y = c('AGEP'),\n                                  z = c('SEX'),\n                                  geo_lvl = 'All',\n                                  specs = NULL) {\n  map_dfr(x_multi, ~ user_input(x = .x,\n                                y = y,\n                                z = z,\n                                geo_lvl = geo_lvl,\n                                specs = specs))\n}\n\nNow, we can test this multi-year function with 2021 and 2022 data and compare it to the single year results from before of the same variables, but looking at just 2021.\n\nmulti_year_user_input(x_multi = c(2021, 2022),\n                      y = c(\"AGEP\", \"GRPIP\"),\n                      z = c(\"SEX\", \"SCHL\"))  \n\n# A tibble: 6,625,977 × 6\n    AGEP GRPIP PWGTP SEX   SCHL   Year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt;\n 1    36     0    35 1     11     2021\n 2    19     0    35 1     19     2021\n 3    57     0    70 1     22     2021\n 4    29     0   149 1     14     2021\n 5    26     0   177 1     1      2021\n 6    80     0    14 2     21     2021\n 7    47     0    14 1     16     2021\n 8    80     0    95 2     14     2021\n 9    21     0    31 1     19     2021\n10    19     0    27 2     19     2021\n# ℹ 6,625,967 more rows"
  },
  {
    "objectID": "Data-Processing.html#writing-a-generic-function-for-summarizing",
    "href": "Data-Processing.html#writing-a-generic-function-for-summarizing",
    "title": "PUMS Census Data Processing in R",
    "section": "Writing a Generic Function for Summarizing",
    "text": "Writing a Generic Function for Summarizing\nNext, we can begin writing a generic summary function. For the census summary method, let’s write a function that produces means and standard deviations for our numeric variable(s) and counts for our categorical variable(s). This function will take three arguments: the tibble with class census, the numeric variable(s) to summarize, and the categorical variable(s) to summarize. The PWGTP (weight) variable is the only numeric variable that the user won’t be able to summarize, by default.\n\nsummary.census &lt;- function(object, numeric_vars = NULL, category_vars = NULL) {\n  # Set our default numeric (except PWGTP) and categorical variables for summarizing.\n  all_numeric &lt;- setdiff(names(object)[sapply(object, is.numeric)], c(\"PWGTP\", \"Year\")) # Also exclude 'Year' from summarizing.\n  all_categorical &lt;- names(object)[sapply(object, is.factor)]\n  \n  # Use the specified variable from the user or use the default if NULL response.\n  num_var &lt;- if (is.null(numeric_vars)) all_numeric else intersect(numeric_vars, all_numeric)\n  cat_var &lt;- if (is.null(category_vars)) all_categorical else intersect(category_vars, all_categorical)\n\n  weight &lt;- as.numeric(object$PWGTP)\n\n  results &lt;- list()\n  \n  # Create the numeric summary.\n  for (var in num_var) {\n    x &lt;- as.numeric(object[[var]])\n    sample_mean &lt;- sum(x * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE)\n    std_dev &lt;- sqrt(sum((x^2) * weight, na.rm = TRUE) / sum(weight, na.rm = TRUE) - sample_mean^2)\n\n    results[[paste0(\"Mean_\", var)]] &lt;- sample_mean\n    results[[paste0(\"SD_\", var)]] &lt;- std_dev\n  }\n  # Create the categorical summary.\n  for (var in cat_var) {\n    freq &lt;- object %&gt;%\n      group_by(.data[[var]]) %&gt;%\n      summarise(weighted_count = sum(PWGTP)) %&gt;%\n      arrange(desc(weighted_count))\n\n    results[[paste0(\"Counts_\", var)]] &lt;- freq\n  }\n\n  return(results)\n}\n\nHere is a test of our summary function.\n\ncensus_data &lt;- user_input(x = 2022,\n                          y = c(\"AGEP\", \"GRPIP\"),\n                          z = c(\"SEX\", \"SCHL\"))\n\nsummary(census_data)\n\n$Mean_AGEP\n[1] 39.54931\n\n$SD_AGEP\n[1] 23.26344\n\n$Mean_GRPIP\n[1] 11.05109\n\n$SD_GRPIP\n[1] 22.74651\n\n$Counts_SEX\n# A tibble: 2 × 2\n  SEX   weighted_count\n  &lt;fct&gt;          &lt;dbl&gt;\n1 2          168090101\n2 1          165197461\n\n$Counts_SCHL\n# A tibble: 25 × 2\n   SCHL  weighted_count\n   &lt;fct&gt;          &lt;dbl&gt;\n 1 16          61497410\n 2 21          53503839\n 3 19          36607052\n 4 22          23469572\n 5 20          22064816\n 6 18          17905754\n 7 1           11914151\n 8 0           10619594\n 9 17           9731204\n10 14           8368704\n# ℹ 15 more rows\n\n\nNow, let’s create a generic plot() function for a census class tibble. The user will need to specify one categorical variable and one numeric variable for plotting purposes.\n\nlibrary(quantreg)\nlibrary(ggplot2)\n\n\nplot.census &lt;- function(object, cat_var, num_var) {\n  \n  # Potential errors. Be sure that both variables exist in the data.\n  if (!(cat_var %in% names(object))) {\n    stop(paste0(\"Categorical variable '\", cat_var, \"' not found in the data.\"))\n  }\n  if (!(num_var %in% names(object))) {\n    stop(paste0(\"Numeric variable '\", num_var, \"' not found in the data.\"))\n  }\n\n  # Be sure the categorical variable is a factor.\n  if (!is.factor(object[[cat_var]])) {\n    stop(paste0(\"Variable '\", cat_var, \"' is not a factor (categorical).\"))\n  }\n\n  # Be sure the numeric variable is numeric.\n  if (!is.numeric(object[[num_var]])) {\n    stop(paste0(\"Variable '\", num_var, \"' is not numeric.\"))\n  }\n\n  ggplot(census_data,\n         aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) + \n    geom_boxplot() +\n    labs(x = cat_var, y = num_var)\n}\n\nWe will use the same census_data example that we used to test our summary() function and now apply it to our generic plot() function. The code chunk below will plot the SEX variable against the AGEP variable, as specified by the user. In this example, we are using `census_data’, where the user has previously specified the year 2022.\n\nplot(census_data, cat_var = \"SEX\", num_var = \"AGEP\")\n\n\n\n\n\n\n\n\nAs we can see in the box plot, according to 2022 census_data, men (1) and women (2) seem to have very similar age distributions. However, the women in this sample have a slightly higher age range, which could point towards the fact that women often have a slightly higher life expectancy than the men in this sampling."
  }
]