[
  {
    "objectID": "Data Processing.html",
    "href": "Data Processing.html",
    "title": "Data Processing",
    "section": "",
    "text": "The following document explores the extraction of the Public Use Microdata Sample Census data using the API that gives person-level data between, and including, the years 2010 and 2022."
  },
  {
    "objectID": "Data Processing.html#a-quick-intro",
    "href": "Data Processing.html#a-quick-intro",
    "title": "Data Processing",
    "section": "",
    "text": "The following document explores the extraction of the Public Use Microdata Sample Census data using the API that gives person-level data between, and including, the years 2010 and 2022."
  },
  {
    "objectID": "Data Processing.html#now-for-the-code-to-query-this-data",
    "href": "Data Processing.html#now-for-the-code-to-query-this-data",
    "title": "Data Processing",
    "section": "Now for the code to query this data",
    "text": "Now for the code to query this data\nWe know we want to use the tidyverse package, as we’ve established in the ST 558 course that tibbles are easy to manipulate and format. Let’s also load in the tidycensus package, which works with this Census API. The jsonlite package helps to parse JSON data. The httr package is used to effectively deal with URLs.\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(tidycensus)\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\nlibrary(httr)\n\nNow that we have the libraries loaded, we can use the example function call and the httr package to ‘GET’ the structure of the example page.\n\nurl_census &lt;- 'api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'\ncensus_info &lt;- httr::GET(url_census)\nstr(census_info, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 2\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:937508] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-09-26 18:36:16\"\n $ times      : Named num [1:6] 0.0633 0.0127 0.0559 0.121 0.38 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nLet’s try creating a helper function, parsing_fun, that takes what we found from the GET() function and turn it into a nicely formatted tibble. We need to do some corrections with formatting, as the column names weren’t initially recognized. The data we are interested in is in the content portion of census_info. The str() function above gives a good visual for this.\n\nparsing_fun &lt;- function(response) {\n  parsed &lt;- fromJSON(rawToChar(response$content))\n  content_info &lt;- as_tibble(parsed)\n  colnames(content_info) &lt;- content_info[1,]\n  content_info &lt;- content_info[-1,]\n  content_info\n}\n\nNow, we can begin the actual creation of the function. First, let’s specify the options for a few of the function arguments we will use.\n\nnumeric_vars &lt;- c('AGEP','GASP','GRPIP','JWAP', 'JWDP','JWMNP')\ncategory_vars &lt;- c('FER','HHL','HISPEED', 'JWTRNS','SCH','SCHL','SEX')\ngeo_vars &lt;- c('All', 'Region', 'Division', 'State')\n\nSecond, we can create the single year function, user_input, which has default values for the first four arguments and the fifth argument is optional. We begin with the year input, where we need to ensure a valid year was entered, then the numeric, category, and geography levels are validated. The numeric variables are then converted to numeric or time values, depending on the attribute. The categorical variables are turns in to factors.\nUsers can specify specific Regions, Divisions, or States in the fifth (optional) argument.\nFinally, the variable ‘Year’ is added to the output_tibble to specify which year the observation data came from. This is important when querying multiple years in the next part.\n\nuser_input &lt;- function(x=c(2022),\n                       y=c(\"AGEP\"),\n                       z=c(\"SEX\"),\n                       geo_lvl=\"All\",\n                       specs=NULL) {\n  if (!all(x %in% c(2010:2022))) {\n    stop('expected a number')\n  }\n  \n  if (!all(y %in% numeric_vars)) {\n    stop('expected a numeric variable from the following list: AGEP, GASP, GRPIP, JWAP, JWDP, JWMNP')\n  }\n  number_vars_specified &lt;- unique(c(y, \"PWGTP\"))\n\n  if (!all(z %in% category_vars)) {\n    stop('expected a categorical variable from the following list: FER, HHL, HISPEED, JWTRNS, SCH, SCHL, SEX')\n  }\n  category_vars_specified &lt;- z\n  variable_combo &lt;- paste(c(number_vars_specified, category_vars_specified), collapse = ',')\n  if (!geo_lvl %in% geo_vars){\n    stop('expected a geographical level from the following list: All, Region, Division, State')\n  }\n  \n  url_base &lt;- paste0('https://api.census.gov/data/', x, '/acs/acs1/pums?get=', variable_combo)\n  \n  if (!is.null(specs)) {\n    filter &lt;- paste0('&', names(specs), '=', specs)\n    url_base &lt;- paste0(url_base, paste(filter, collapse = ''))\n  }\n  response &lt;- GET(url_base)\n  \n  output_tibble &lt;- parsing_fun(response)\n  \n  for (i in numeric_vars) {\n    if (i %in% names(output_tibble)) {\n      output_tibble[[i]] &lt;- as.numeric(output_tibble[[i]])\n    }\n  }\n  \n  time_vars &lt;- intersect(numeric_vars, c('JWAP','JWDP'))\n  \n  for (i in time_vars) {\n    if (i %in% names(output_tibble)) {\n      output_tibble[[i]] &lt;- as.numeric(output_tibble[[i]])+0.5 #halfway point\n    }\n  }\n  \n  for (i in category_vars) {\n    if (i %in% names(output_tibble)) {\n      output_tibble[[i]] &lt;- as.factor(output_tibble[[i]])\n    }\n  }\n  \n  output_tibble$Year &lt;- x\n  \n  return(output_tibble)  \n}\n\nLet’s test how this works using a ‘Default’ input, where no arguments have specific values changed from the default.\n\ndefault_tibble &lt;- user_input()\n\nWarning: The `x` argument of `as_tibble.matrix()` must have unique column names if\n`.name_repair` is omitted as of tibble 2.0.0.\nℹ Using compatibility `.name_repair`.\n\ndefault_tibble\n\n# A tibble: 3,373,378 × 4\n    AGEP PWGTP SEX    Year\n   &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt;\n 1    17 3     2      2022\n 2    73 42    1      2022\n 3    22 11    1      2022\n 4    82 32    2      2022\n 5    19 31    2      2022\n 6    88 32    1      2022\n 7    80 45    1      2022\n 8    33 37    1      2022\n 9    44 29    1      2022\n10    36 55    1      2022\n# ℹ 3,373,368 more rows\n\n\nThe following is the testing of the single year function where the user specified 2021 as the year, AGEP and GRPIP as the numeric variables, and SEX and SCHL as the categorical variables. Here, the geogrphy level is not specified, so it defaults to a value of ‘All.’\n\nuser_input(x = 2021,\n           y = c(\"AGEP\", \"GRPIP\"),\n           z = c(\"SEX\", \"SCHL\"))  \n\n# A tibble: 3,252,599 × 6\n    AGEP GRPIP PWGTP SEX   SCHL   Year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt;\n 1    36     0 35    1     11     2021\n 2    19     0 35    1     19     2021\n 3    57     0 70    1     22     2021\n 4    29     0 149   1     14     2021\n 5    26     0 177   1     1      2021\n 6    80     0 14    2     21     2021\n 7    47     0 14    1     16     2021\n 8    80     0 95    2     14     2021\n 9    21     0 31    1     19     2021\n10    19     0 27    2     19     2021\n# ℹ 3,252,589 more rows\n\n\nLooks good! Now, we can wrap this single year function into a multi_year_user_input function. The user can specify multiple years, instead of just one, and this data is combined into a tibble.\n\nmulti_year_user_input &lt;- function(x_multi = 2022,\n                                  y = c('AGEP'),\n                                  z = c('SEX'),\n                                  geo_lvl = 'All',\n                                  specs = NULL) {\n  map_dfr(x_multi, ~ user_input(x = .x,\n                                y = y,\n                                z = z,\n                                geo_lvl = geo_lvl,\n                                specs = specs))\n}\n\nNow, we can test this multi-year function with 2021 and 2022 data and compare it to the single year results from before of the same variables, but looking at just 2021.\n\nmulti_year_user_input(x_multi = c(2021, 2022),\n                      y = c(\"AGEP\", \"GRPIP\"),\n                      z = c(\"SEX\", \"SCHL\"))  \n\n# A tibble: 6,625,977 × 6\n    AGEP GRPIP PWGTP SEX   SCHL   Year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt;\n 1    36     0 35    1     11     2021\n 2    19     0 35    1     19     2021\n 3    57     0 70    1     22     2021\n 4    29     0 149   1     14     2021\n 5    26     0 177   1     1      2021\n 6    80     0 14    2     21     2021\n 7    47     0 14    1     16     2021\n 8    80     0 95    2     14     2021\n 9    21     0 31    1     19     2021\n10    19     0 27    2     19     2021\n# ℹ 6,625,967 more rows"
  }
]